#+TITLE: MyBatis


* 历史背景
** 背景

- SSH, Spring + Struts1,2 + Hibernate
- SSM, Spring + SpringMVC + MyBatis

dao, 数据库连接

#+BEGIN_SRC sql
  create table person (id int auto_increment primary key, name varchar(20), weixin varchar(20));
  insert into person (name, weixin) values ('张学友', '110'), ('刘亦菲', '220');
#+END_SRC

jdbc:
- 自行管理连接，语法比较繁琐
- 容易写出不健壮的代码
- 容易忽略业务逻辑

ORM:
- Object-Relational Mapping


#+BEGIN_SRC java
  public class Person {
      private int id;
      private String name;
      private String weixin;

      // getter..setter
  }
#+END_SRC


** Hibernate

想法:
1. 助手，读取数据库，获取相关的类，建立一种映射关系。session
2. 使用助手操作数据库:
   #+BEGIN_SRC java
     Book book = new Book("hhhh", 222);
     session.save(book);

     Book book1 = session.get(2L, Book.class);
     System.out.println(book1.getName());
   #+END_SRC

示例，首先，在项目中添加依赖:
#+BEGIN_SRC sgml
  <dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-core</artifactId>
    <version>5.3.6.Final</version>
  </dependency>

  <dependency>
    <groupId>org.mariadb.jdbc</groupId>
    <artifactId>mariadb-java-client</artifactId>
    <version>2.3.0</version>
  </dependency>
#+END_SRC

其次，创建配置文件 hibernate.cfg.xml:
#+BEGIN_SRC sgml
  <?xml version='1.0' encoding='UTF-8'?>
  <!DOCTYPE hibernate-configuration PUBLIC
   "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
   "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">

  <hibernate-configuration>
    <session-factory>
      <property name="hibernate.connection.driver_class">org.mariadb.jdbc.Driver</property>
      <property name="hibernate.connection.url">jdbc:mariadb://localhost:3306/lagou</property>
      <property name="hibernate.connection.username">vip</property>
      <property name="hibernate.connection.password">vip</property>
      <property name="hibernate.dialect">org.hibernate.dialect.MariaDB10Dialect</property>

      <property name="hibernate.show_sql">true</property>

      <mapping class="com.nf147.sss.entity.Person" />
    </session-factory>
  </hibernate-configuration>
#+END_SRC

然后，创建 entity:
#+BEGIN_SRC java
  @Entity
  public class Person {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
      private String name;
      private String weixin;

      // getter..setter
  }
#+END_SRC

之后，就可以使用了:
#+BEGIN_SRC java
  public static void main( String[] args )
  {
      Configuration configuration = new Configuration();
      Configuration configure = configuration.configure("hibernate.cfg.xml");
      SessionFactory sessionFactory = configuration.buildSessionFactory();

      Session session = sessionFactory.openSession();
      Person person = session.get(Person.class, 1L);
      System.out.println(person.getName());

      System.out.println(session.get(Person.class, 2L).getName());

      // 新增
      Person fbb = new Person();
      fbb.setName("fanbingbing");
      fbb.setWeixin("80000000000");
      session.save(fbb);

      session.close();
      sessionFactory.close();
  }
#+END_SRC

** MyBatis

- select id, name, wexin from person where ?
- delete from person where id = ?
- update person set..

给常用的语句，每个语句，起个名字。
#+BEGIN_SRC sgml
  <yujus>
    <yuju name="yuju1">
      select * from person
    </yuju>

    <yuju name="yuju2">
      delete from person
    </yuju>
  </juyus>
#+END_SRC

使用一个帮手，帮我们做事情:
#+BEGIN_SRC java
  Helper helper; // 这个就是我们请的帮手，它能够帮我们连接、关闭数据库，能够帮我们进行数据库的查询

  Person person = (Person) helper.help("yuju1");
  helper.help("yuju2");
#+END_SRC

三件事:
1. 语句
2. 传入参数
3. 返回值

* 核心配置文件 (mybatis-config.xml)
** 配置文件示例

#+BEGIN_SRC sgml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">

  <configuration>
    <!--【定义变量，用于复用】-->
    <!-- 可以通过外部文件加载变量，也可以直接通过 property 定义 -->
    <properties resource="jdbc.properties">
      <property name="password" value="vvvvvip" />
      <property name="hello" value="world" />
    </properties>

    <!--【内部设置】-->
    <!-- 通过修改这些参数，更改 Mybatis 的内在行为 -->
    <settings>
      <setting name="multipleResultSetsEnabled" value="true"/>
      <setting name="useColumnLabel" value="true"/>
      <setting name="useGeneratedKeys" value="false"/>
      <setting name="autoMappingBehavior" value="PARTIAL"/>
      <setting name="autoMappingUnknownColumnBehavior" value="WARNING"/>
      <setting name="defaultExecutorType" value="SIMPLE"/>
      <setting name="defaultStatementTimeout" value="25"/>
      <setting name="defaultFetchSize" value="100"/>
      <setting name="safeRowBoundsEnabled" value="false"/>
      <setting name="mapUnderscoreToCamelCase" value="false"/>
      <setting name="jdbcTypeForNull" value="OTHER"/>
      <setting name="cacheEnabled" value="true"/>
      <setting name="lazyLoadingEnabled" value="true"/>
      <setting name="localCacheScope" value="SESSION"/>
      <setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/>
    </settings>

    <!--【设置别名】可以简化在 xml 中的完全限定名的使用 -->
    <!-- 通过 package 方式，可以简化写法 -->
    <typeAliases>
      <!--<typeAlias alias="Author" type="com.nf147.sss.entity.Author"/>-->
      <!--<typeAlias alias="Blog" type="com.nf147.sss.entity.Blog"/>-->
      <!--<typeAlias alias="Comment" type="com.nf147.sss.entity.Comment"/>-->
      <package name="com.nf147.sss.entity" /> <!-- 可以跟 @Alias 结合使用 -->
    </typeAliases>

    <!--【类型处理器】-->
    <!-- MyBatis 已经内置了多数的类型处理器，能应付绝大多数的类型转换 -->
    <!-- 如果我们有特定的需求，可以定义自己的处理器(实现 TypeHandler 接口或继承相关实现类) -->
    <typeHandlers>
      <!--<typeHandler handler="com.nf147.sss.handler.FakeIntegerHandler" />-->
      <package name="com.nf147.sss.handler" />
    </typeHandlers>

    <!--【实例化结果对象】-->
    <!-- 默认使用 DefaultObjectFactory 来实例化结果对象，我们也可以定义自己的，覆盖原来的 -->
    <objectFactory type="com.nf147.sss.handler.OurObjectFactory">
      <property name="someProperty" value="100"/>
    </objectFactory>

    <!--【插件】用来拦截并改变 MyBatis 的工作流 -->
    <!-- 它本质就是一个拦截器 -->
    <!-- 定义插件，需要实现 Interceptor 接口即可 -->
    <plugins>
      <plugin interceptor="com.nf147.sss.plugin.MyPlugin">
        <property name="msg" value="hello, world"/>
        <property name="dbtype" value="mysql" />
      </plugin>
    </plugins>

    <!-- 【配置连接环境】-->
    <!-- 可以配置多个，每一个需要配置两部分: 事务 + 数据源 -->
    <environments default="prod">
      <environment id="dev">
        <transactionManager type="JDBC|MANAGED" />
        <dataSource type="UNPOOLED|POOLED|JNDI|com.nf147.sss.ds.MyDataSource">
          <property name="driver" value="${driver}"/>
          <property name="url" value="${url}"/>
          <property name="username" value="${username}"/>
          <property name="password" value="${password}"/>
        </dataSource>
      </environment>
    </environments>

    <!--【多数据标识】用于在 MyBatis 中使用多数据库语句 -->
    <databaseIdProvider type="DB_VENDOR">
      <property name="MySQL" value="my"/>
      <property name="SQL Server" value="sqlserver"/>
      <property name="DB2" value="db2"/>
      <property name="Oracle" value="oracle" />
    </databaseIdProvider>

    <!--【指定映射器】-->
    <!-- 有如下四种写法 -->
    <mappers>
      <mapper resource="PersonMapper.xml" />
      <mapper url="d:/wenjian/de/weizhi/Person.xml" />
      <mapper class="com.nf147.sss.dao.CommonDAO" />
      <package name="mapper" />
    </mappers>
  </configuration>
#+END_SRC

** TypeHandler 示例

#+BEGIN_SRC java
  @MappedJdbcTypes(JdbcType.Integer)
  public class FakeIntegerHandler extends IntegerTypeHandler {
      @Override
      public void setNonNullParameter(PreparedStatement ps, int i, Integer parameter, JdbcType jdbcType) throws SQLException {
          ps.setInt(i, parameter * parameter);
      }
  }
#+END_SRC

** ObjectFactory 示例

#+BEGIN_SRC java
  public class OurObjectFactory extends DefaultObjectFactory {
      @Override
      public <T> T create(Class<T> type) {
          System.out.println("拒绝配合");
          return null;
      }
  }
#+END_SRC

** DataSourceFactory 示例

#+BEGIN_SRC java
  public class MyDataSourceFactory extends UnpooledDataSourceFactory {
      public MyDataSourceFactory() {
          this.dataSource = new ComboPooledDataSource();
          ((ComboPooledDataSource) this.dataSource).setCheckoutTimeout(30);
      }
  }
#+END_SRC

** Plugin 示例

#+BEGIN_SRC java
  @Intercepts({@Signature(
    type= Executor.class,
    method = "update",
    args = {MappedStatement.class,Object.class})})
  public class MyPlugin implements Interceptor {
        public Object intercept(Invocation invocation) throws Throwable {
            System.out.println("在这里，进行拦截、修改");
            return invocation.proceed();
        }
        public Object plugin(Object target) {
            return Plugin.wrap(target, this);
        }
        public void setProperties(Properties properties) {
            System.out.println(properties.getProperty("hello"));
        }
    }
#+END_SRC
* 映射文件 (EntityMapper.xml)

示例 XML:
#+BEGIN_SRC sgml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

  <mapper namespace="com.nf147.sss.dao.CommonDAO">
      <sql id="sql1"></sql>

      <resultMap id="rmAuthor" type="author">
          <!--<id property="id" column="id" />-->
          <!--<result property="name" column="name" />-->
          <result property="city" column="chengshi" />
      </resultMap>

      <select id="selectAll" resultMap="rmAuthor">
          select
            id,
            name,
            chengshi
          from sss_author
      </select>

      <resultMap id="rmBlog" type="blog">
          <!--基本的数据类型，使用 id/result-->

          <id property="id" column="id" />
          <result property="title" column="title" />
          <result property="content" column="content" />

          <!--association 表示的是 has One 的关系-->

          <!--第一种方式：nested select-->
          <!--<association property="author" javaType="author"-->
              <!--column="aid" select="com.nf147.sss.dao.CommonDAO.selectAuthorById" />-->

          <!--第二种方式，nested resultMap-->
          <!--
          <association property="author" javaType="author">
              <id property="id" column="author_id" />
              <result property="name" column="author_name" />
              <result property="city" column="author_city" />
          </association>
          -->

          <!--
          <association property="author" javaType="author" columnPrefix="author_">
              <id property="id" column="id" />
              <result property="name" column="name" />
              <result property="city" column="city" />
          </association>
          -->

          <association property="author" javaType="author" columnPrefix="author_" resultMap="a2" />


          <!--Collection 表示的是 Has Many 的关系-->
          <collection property="comments" ofType="comment" columnPrefix="comment_">
              <id property="id" column="id" />
              <result property="body" column="body" />
          </collection>
      </resultMap>

      <resultMap id="a2" type="author">
          <id property="id" column="id" />
          <result property="name" column="name" />
          <result property="city" column="city" />
      </resultMap>

      <!-- result type -->
      <select id="selectAuthorById" resultType="author">
          select id, name, city from sss_author where id=#{id}
      </select>

      <!-- result map -->
      <select id="selectBlogs" resultMap="rmBlog">
          select
            b.id         as id,
            b.title      as title,
            b.content    as content,
            a.id         as author_id,
            a.name       as author_name,
            a.city       as author_city,
            c.id         as comment_id,
            c.body       as comment_body
          from
            sss_blog b
            left join sss_author a on b.author_id = a.id
            left join sss_comment c on c.blog_id = b.id
      </select>



      <!-- DML 语句 -->

      <!-- 主键策略 -->
      <insert id="insertAuthor" useGeneratedKeys="false" keyProperty="id" keyColumn="id">
          <selectKey keyProperty="id" resultType="int" order="BEFORE">
              select floor(rand()*1000)
          </selectKey>
          insert into sss_author (id, name, city) values (#{id}, #{name}, #{city})
      </insert>
      <update id="updateBlog">
          update sss_blog set content = #{content} where id = #{id}
      </update>
      <update id="updateBlog2" parameterType="blog" databaseId="oracle">
          update sss_blog set content = #{content} where id = #{id} and 1=1
      </update>
      <update id="updateBlog2" parameterType="blog" databaseId="mysql">
          update sss_blog set content = #{content} where id = #{id}
      </update>
      <update id="updateBlog3" statementType="CALLABLE">
          update sss_blog set content = #{content} where id = #{id}
      </update>
      <delete id="ddd" />
  </mapper>
#+END_SRC

* 常用 API

#+BEGIN_SRC java
  public static void main(String[] args) throws Exception {
      InputStream in = Resources.getResourceAsStream("mybatis-config.xml");
      SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in);
      SqlSession session = factory.openSession();

      // selectOne
      // 重载有两个方法，第二个是条件参数
      Object o = session.selectOne("xxx.findById");
      Object o = session.selectOne("xxx.findById", 3);
      Object o = session.selectOne("xxx.findByName", "毛%");
      Object o = session.selectOne("xxx.findByNameAndCity", new HashMap<String, String>() {{
          put("name", "郭敬明");
          put("city", "上海");
      }});
      Object o = session.selectOne("xxx.findByNameAndCity", new Author("鲁迅", "浙江"));

      // selectList
      // 结果封装为 List
      // 重载有三个方法
      // 第三个参数，表示分页 (RowBounds)
      List<Object> lst = session.selectList("findAll");
      List<Object> lst = session.selectList("findAllLimit", 1);
      RowBounds rowBounds = new RowBounds(2, 3);
      List<Object> lst = session.selectList("findAll", null, rowBounds);
      lst.forEach(System.out::println);

      // 结果封装为 ResultMap
      Map<Object, Object> map = session.selectMap("findAll", null, "name", new RowBounds(0, 2));
      System.out.println(map);
      System.out.println(map.get("鲁迅"));

      // 结果封装为 Cursor，类似 ResultSet 遍历的语法
      Cursor<Object> cs = session.selectCursor("findAll");
      Iterator<Object> iterator = cs.iterator();
      while (iterator.hasNext()) {
          System.out.println(iterator.next());
      }

      // select，通过回调的方式，处理返回结果
      session.select("findAll", new ResultHandler() {
              @Override
              public void handleResult(ResultContext resultContext) {
                  if (resultContext.getResultCount() % 2 == 0)
                      System.out.println(">>>> " + resultContext.getResultCount() + " : " + resultContext.getResultObject());
              }
          });

      // Mapper，更通用，更方便的方式
      CommonDAO mapper = session.getMapper(CommonDAO.class);
      List<Author> authors = mapper.findAll(new RowBounds(1, 3));
      authors.forEach(System.out::println);

      // 可以通过注解的方式传入多参数
      // 使用 RowBounds 类型的参数，表示分页
      List<Author> authors1 = mapper.findAllIdBiggerThan(3, new RowBounds(1, 2));
      authors1.forEach(System.out::println);
  }
#+END_SRC

* 示例表

#+BEGIN_SRC sql
  create table sss_author (
         id int auto_increment primary key,
         name varchar(30),
         city varchar(30));
  create table sss_blog (
         id int auto_increment primary key,
         title varchar(30),
         content text,
         author_id int);
  create table sss_comment (
         id int auto_increment primary key,
         body varchar(30),
         blog_id int,
         author_id int);

  insert into sss_author (name, city) values
         ('郭敬明', '上海'),
         ('鲁迅', '浙江'),
         ('毛泽东', '湖南'),
         ('周立波', '上海'),
         ('周恩来', '浙江'),
         ('王阳明', '江西');

  insert into sss_blog (title, content, author_id) values
         ('呐喊','醒醒吧，孩子', 2),
         ('朝花夕拾', '三味书屋', 2),
         ('而已集', '苍蝇就是苍蝇', 2);

  insert into sss_comment (body, blog_id, author_id) values
         ('这是一本好书，我是写不出来', 1, 1),
         ('很好，已阅。', 1, 2);

  select * from sss_blog;
  select * from sss_author;
  select * from sss_comment;

#+END_SRC
