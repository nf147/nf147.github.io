#+TITLE: Spring Framework


* vs. 工厂模式

#+BEGIN_SRC java
  public class ServiceFactory {
      public Object getServiceObject (String name) {
          if (name.equals("bs")) {
              A a = new A();
              B b = new B(a); // 构造器
              MyBatiscConnection conn = new MyBatiscConnection();
              LogUtil log = new LogUtil();
              BookService bookservice = new BookService();

              b.setA(a); // setter
              conn.setB(b);
              bookservice.setConn(conn);
              LogUtil.setConn(conn);
              bookservice.setLogger(log);

              return bookservice;
          }
      }
  }

  main () {
      ServiceFactory sf = new ServiceFactory();

      BookService bookservice = sf.getServiceObject("bs");
      bookservice.sellBook();
  }
#+END_SRC

将工厂模式切割，分为解析程序和 xml 文件。

xml 暴露出来，用来 *描述* 工厂需要实例化的类以及他们之间的关系。

#+BEGIN_SRC sgml
  <xml>
    <!-- 之前命令；描述 -->
    <bean id="a" class="xxx.yyy.A" />
    <bean id="b" class="xxx.yyy.B">
      <property name="a" bean="a" />
    </bean>
    <bean id="conn" class="xxx.yyy.MyBConn">
      <property name="b" bean="b" />
    </bean>
    <bean id="log" class="xxx.yyy.LogUtil">
      <property name="conn" bean="conn" />
    </bean>
    <bean id="bookservice" class="xxx.BookService">
      <property name="conn" bean="conn" />
      <property name="log" bean="log" />
    </bean>
  </xml>
#+END_SRC

* 接口

最核心的 jar 包:
- spring-core
- spring-bean
- spring-context

最核心的接口是 ~BeanFactory~，它用来描述 IOC 容器:

#+DOWNLOADED: c:/Users/nf147/AppData/Local/Temp/clip.png @ 2018-12-13 03:01:52
[[file:img/clip_2018-12-13_03-01-52.png]]

它很干净，很纯粹，最主要的方法是 ~getBean~ 用来给调用方返回一个实例化好的对象。

在实际运用中，需要一些周边功能，比如加载资源/国际化/等等，Spring 为此提供了 ~ApplicatinContext~
接口。它本身是 BeanFactory 的一个实现:

[[file:img/clip_2018-12-13_03-04-54.png]]

可以看到，ApplicationContext 除了实现了 BeanFactory，还实现了其他一些
实用的接口。因此，它是在 Spring 中操作一切的核心。

这是 *门面模式* 的一种典型使用。


* 配置
** 传统的方式 xml

这种方式，充分利用了 xml 文件的优势:
- 接受度比较高，语法简单
- 表达能力比较强
- 生态比较完整，基于 xml 的校验、解析等比较完善

所以，最开始的时候，描述工厂里 bean 声明的方式，选用的就是 xml

#+BEGIN_SRC sgml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

      <bean id="bs1" class="learning.spring.BookServiceImpl" />
      <bean id="bs2" class="learning.spring.BookService2Impl" />

      <!--<bean id="bs2" class="learning.spring.BookServiceImplImpl" />-->

      <!--<bean id="bs3" class="learning.spring.BookServiceImplImpl" />-->
  </beans>
#+END_SRC

但是:
- 很多人不喜欢 xml 这种标签式的语法。写起来麻烦，看起来不舒服
- xml 方式过于重型
- xml 语法校验虽然强大，但不够强大
- xml 虽然灵活，但不够灵活

所以，就产生了很多其他的叛逆的想法

** 基于 Java 的方式进行配置

#+BEGIN_SRC java
  @Configuration
  public class SuibianSpringConfig {

      // <bean id="bs1" class="learning.spring.BookServiceImpl" />
      @Bean
      public BookService bs1() {
          if (Math.random() > 0.5) {
              // 构造器注入
              return new BookService2Impl(bookDAO());
          } else {
              // setter 注入
              BookService bs = new BookServiceImpl();
              bs.setBookDAO(bookDAO());
              return bs;
          }
      }
    
      @Bean
      public BookDAO bookDAO () {
          return new BookDAO();
      }
  }

#+END_SRC

** 混合双打

Java Style 中混入 XML Style:
#+BEGIN_SRC java
  @Configuration
  @ImportResource(locations = "learning/spring/my-spring.xml")
  public class SuibianSpringConfig {

      // <bean id="bs1" class="learning.spring.BookServiceImpl" />
      @Bean
      public BookService bs1() {
          System.out.println(bookDAO());
          if (Math.random() > 0.5) {
              return new BookService2Impl();
          } else {
              return new BookServiceImpl();
          }
      }

      @Bean
      public BookDAO bookDAO () {
          return new BookDAO();
      }
  }

#+END_SRC

XML style 中混入 Java Style:
#+BEGIN_SRC sgml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

      <bean id="bs2" class="learning.spring.BookService2Impl" />
      <bean class="learning.spring.configuration.SuibianSpringConfig" />
  </beans>
#+END_SRC
* 装配 (Wiring)

#+BEGIN_QUOTE

创建应用对象之间协作关系的行为，通常称为装配 (Wiring)。这是依赖注入 (DI) 的本质。
#+END_QUOTE

装配的基础，是使用配置文件对 Bean 的关系进行声明。

总结起来，在 Spring 中，声明 Bean 一共有三种方式:
1. 在 XML Style 的配置中，使用 ~<bean />~ 节点
2. 在 Java Style 的配置中，使用 ~@Bean~ 注解
3. 开启 Component 扫描，然后使用相关注解: ~@Component/@Controller/@Service/@Repository~

** Wiring in XML

装配:
#+BEGIN_SRC sgml
  <!-- 最简单的声明 -->
  <bean class="package.Dog" /> <!-- Class.forName("package.Dog").newInstance(); -->
  <bean id="xxx" class="包名.类的名字" />

  <!-- 对象内部必须要有数据，所以要给他数据 -->

  <!-- 构造器注入 -->
  <bean id="donkey" class="learning.components.Donkey">
    <constructor-arg index="0" value="得水" />
    <constructor-arg index="1" value="333" />
  </bean>

  <!-- 属性注入 -->
  <bean class="learning.components.Goal" id="goal">
    <property name="name" value="多利" />
    <property name="countOfLegs" value="4" />
  </bean>

  <!-- 集合的注入 -->
  <bean class="learning.components.Goal" id="goal">
    <property name="name" value="多利" />
    <property name="legs">
       <list> <!-- map/arrary/set/prop 同理 -->
          <value>leg1</value>
          <value>leg2</value>
          <value>leg3</value>
       </list>
    </property>
  </bean>

  <!-- Bean 的依赖 -->
  <bean class="learning.components.Goal" id="goal">
    <property name="xxx">
        <ref bean="xxx" />
    </property>
    <property name="yyy" ref="yyy" />
    <property name="zzz">
        <bean class="package.Zzz" />
    </property>
  </bean>

  <!-- 使用 C/P/UTIL 命名空间简化使用 -->
  <bean class="learning.components.Goal" id="goal"
        p:name="多利" p:countOfLegs="4"
        p:xxx-ref="xxx" p:aliases-ref="aliaslist" />

  <util:list id="aliaslist">
    <value>kkkk1</value>
    <value>kkkk2</value>
    <value>kkkk3</value>
  </util:list>

  <!-- 将实例化的工作，委托给工厂 -->
  <bean class="learning.components.AnimalFactory" id="goalmiemie" factory-method="xxx" />
  <bean class="learning.components.AnimalFactory" id="deshui" factory-method="yyy" />

  <!-- 包含其他的配置文件到这里 -->
  <import resource="xxxxx.xml" />
#+END_SRC

另外:
- denpend-on 定义顺序
- parent 定义继承
- scope 定义初始化策略
- lazy 延迟初始化
- alias 定义别名
- import 引入其他的定义文件

** Wiring in JavaConfig

#+BEGIN_SRC java
  @Configuration
  @ComponentScan("包名")
  @ImportResource("..../xxx.xml")
  @Import({ShiroConfig.class, MybatisConfig.class, ScheduleConfig.class})
  public class SpringConfig {
      @Bean
      public Author author () {
          return new Author("luxun");
      }

      @Bean
      public Book book1 (Author author) {
          return new Book("呐喊", author);  // 参数注入
      }

      @Bean(name = "book3")
      public Book book2 () {
          return new Book("呐喊", author());  // 方法调用注入
      }
  }
#+END_SRC

** Wiring with Annotation

首先，需要开启 Component Scanning，即组件扫描:
#+BEGIN_SRC java
  // JavaConfig
  @Configuration
  @ComponentScan("xxx.components")
  public class SpringConfig {
      // ...
  }


  // XMLConfig:
  //
  // <context:component-scan base-package="xxx.components" />
#+END_SRC

声明 Bean 有四个注解:
1. @Component
2. @Controller
3. @Service
4. @Repository

在注解的方式中，要确定 Bean 之间的关系，需要使用下面注解进行 “注入”:
- @Autowired
- @Inject
- @Resource
- @Value

注入的注解：
- 可以放在 field 上，称作属性注入
- 可以放在 constructor 上，称作构造器注入
- 可以放在 setter 方法上，称作 setter 注入

#+BEGIN_SRC java
  @Controller
  public class BookController {
      @Autowired // 属性注入
      BookDAO bookDAO;

      @Autowired // 构造器注入
      public BookController(BookDAO bookDAO) {
          this.bookDAO = bookDAO;
      }

      @Autowired // setter 注入
      public void setBookDAO(BookDAO bookDAO) {
          this.bookDAO = bookDAO;
      }
  }
#+END_SRC

属性注入的写法是最简单的，但不建议使用。原因:
1. ...
2. ...
3. ...

* 生命周期 (Lifecycle)

如果想在 Bean 实例化过程中，做一些额外的事情，
就需要了解 Bean 从产生，到使用，到最后销毁的整个过程。

也就是 Bean 的生命周期。

#+ATTR_HTML: :style width: 500px
[[file:img/clip_2018-12-14_01-43-10.png]]

一个 Bean 从产生到消亡经历了这些过程:

1. Spring 对 bean 进行实例化 (~Instance~)
2. Spring 对 bean 的值或引用进行注入 (~Populate Properties~)
3. 若实现了 BeanNameAware 接口，则调用 setBeanName 方法，即 ~BeanNameAware.setBeanName()~
4. ~BeanFactoryAware.setBeanFactory()~
5. ~ApplicationContextAware.setApplicationContext()~
6. ~BeanPostProcessor.postProcessBeforeInitialization()~
7. ~InitializingBean.afterPropertiesSet()~。若声明了 ~init-method~ 方法，调用之
8. ~BeanPostProcessor.postProcessAfterInitialzation()~
9. *此时 bean 准备就绪，就可以使用了，直到销毁*
10. ~DisposableBean.destroy()~。若 bean 声明了 destory-method 属性，调用之
* 面向切面编程 (AOP, Aspect Oriten Program)

如果对一个对象的方法进行 *扩充* （不改变源码的情况之下，增加或修改行为）的话，一般使用代理模式：
1. +静态代理（太麻烦，一般不会用）+
2. JDK 的动态代理
3. CGLib 的动态代理

但是，直接写代理生成太麻烦了，所以，基于动态代理，产生了 AOP 的编程思想。

#+BEGIN_QUOTE

扩充 = 功能分离。主线功能，支线功能，分开来，实现解耦。
#+END_QUOTE

实际中，基于代理实现的 AOP 方案有很多，比如:
1. AspectJ 实现
2. Jboss AOP 实现
3. Spring AOP 实现

关于 Spring AOP:
- 默认情况下，它基于 JDK 动态代理，所以它需要有接口。
- 但是，也可以调用 CGLib 的代理方式。
- 一般情况下，要为一个类产生代理。如果它有接口，那么 Spring 会采取 JDK 动态代理方式；如果没接口，这时候它会尝试使用 CGLib 的方式产生代理
- Spring AOP 实现，它的功能 *相对来说* 比较弱，只能基于方法进行织入
- Spring AOP 压根就没有想过成为一个全能的 AOP 实现来取代 AspectJ，它主要的精力放在怎么跟容器结合起来更好用，怎么才能更好得配合企业级开发
- Spring AOP 借鉴了 AspectJ 的非常多的特性，比如说，Spring AOP 可以使用跟 AspectJ 完全一样的注解来声明切面。当然要明白，虽然我们可以使用 @AspectJ 的注解，但后面运行的还是实打实的 Spring AOP。
- Spring 中可以非常简单的将其他 AOP 的实现无缝整合到框架中，所以，如果你觉得 Spring AOP 的实现太逊，你完全可以将其他实现整合进来，取代 Spring AOP。


* 概念

[[file:img/clip_2018-12-18_07-19-33.png]]

基本概念:
- *Advice*: 要向目标位置加入什么
- *Pointcut*: 要加到哪些位置
- *Aspect*: 一系列 Advice + Pointcut 的集合。
- *Joinpoint*: Pointcut 中的具体某个位置

*织入(Weaving)* 是把切面应用到目标对象并创建新的代理对象的过程:
- 编译期。切面在目标类编译时被织入。这需要特殊的编译器，比如 AspectJ
- 类加载期。需要特殊的 Classloader。AspectJ 的加载时织入就支持这种方式织入切面
- 运行期。使用动态代理的方式织入。Spring AOP 就是用这种方式织入的

*通知类型*:
- 前置通知(Before advice): 在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）
- 后置通知(After returning advice): 在某连接点正常完成后执行的通知
- 异常通知(After throwing advice): 在方法抛出异常退出时执行的通知
- 最终通知(After (finally) advice): 当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。
- 环绕通知(Around Advice): 包围一个连接点的通知，如方法调用

* 使用 @AspectJ 注解

使用 @AspectJ 的注解，需要相关 jar 包支持:
:org.aspectj:aspectjweaver:1.8.9

而且需要在配置文件中添加:
#+BEGIN_SRC sgml
  <aop:aspectj-autoproxy/>
  <aop:aspectj-autoproxy proxy-target-class="true"/> <!-- cglib support -->

  <!-- or -->
  <bean class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"/>
#+END_SRC

如果使用 Java 配置，需要添加:
#+BEGIN_SRC java
  @Configuration
  @ComponentScan(basePackages = "the.aop")
  @EnableAspectJAutoProxy
  public class SpringConfig {
  }
#+END_SRC

代码示例:
#+BEGIN_SRC java
  @Component
  @Aspect
  public class Audience {
      @Pointcut("execution(** concert.Performance.perform(..))")
      public void xxx();

      @Before("xxx()")
      public void silenceCellPhones() {
          System.out.println("Silencing cell phones");
      }

      @Before("execution(** concert.Performance.perform(..))")
      public void takeSeats() {
          System.out.println("Taking seats");
      }

      @AfterReturning("execution(** concert.Performance.perform(..))")
      public void applause() {
          System.out.println("CLAP CLAP CLAP!!!");
      }

      @AfterThrowing("execution(** concert.Performance.perform(..))")
      public void demandRefund() {
          System.out.println("Demanding a refund");
      }

      @Around("xxx()")
      public void yyyy(ProceedingJoinPoint jp) {
          try {
              System.out.println("aaaa");
              jp.proceed();
              System.out.println("bbb");
          } catch(Throwable e) {
              System.out.println("error");
          }
      }
  }
#+END_SRC

切点表达式:
| 函数          | 说明                                                            |
|---------------+-----------------------------------------------------------------|
| execution()   | execution(* com.*.*(..)), 表示匹配 com 包下所有方法             |
| @annotation() | @annotation(com.Test), 表示匹配所有标注了 @Test 的方法          |
| args()        | arg(int, int), 表示匹配所有参数为 int, int 的方法               |
| @args()       | @arg(Test), 匹配参数注解为 Test 的方法                          |
| within()      | within(sss.*), 匹配 sss 包下所有的类下的所有方法                |
| target()      | target(sss.Test), 匹配所有的类及其子类                          |
| @within()     | @within(sss.Test), 匹配所有使用 Test 注解的类的所有方法         |
| @target       | @target(sss.Test), 所有当前目标对象使用 Test 注解的类的所有方法 |
| this()        | this(sss.Test), 当前 AOP 对象实现了 Test 接口的所有方法         |

* 使用 XML 配置的示例

#+BEGIN_SRC sgml
  <aop:config>
    <aop:aspect ref="loggingAspect"> <!-- 切面类 -->
      <aop:pointcut id="persons" expression="execution(* xxx.*.*(..))" /> <!-- 切点 -->

      <aop:before method="beforeEat" pointcut-ref="persons" />
      <aop:after-returning method="endIt" pointcut-ref="persons" />
      <aop:after-throwing method="whenError" pointcut-ref="execution(** concert.Performance.perform(..))" />
    </aop:aspect>
  </aop:config>
#+END_SRC
